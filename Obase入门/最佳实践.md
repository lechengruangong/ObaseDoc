## dotNet版

在阅读了[快速开始](./快速开始.md)之后,我已经可以使用Obase对Article进行持久化操作了,但现在我又新增了一张表Category表示文章的分类,并且我定义了Category数据模型类
```
/// <summary>
///     文章分类
/// </summary>
public class Category
{
    /// <summary>
    ///     Id 分类标识
    /// </summary>
    public int Id { get; set; }

    /// <summary>
    ///     Name 分类名称
    /// </summary>
    public string Name { get; set; }
    
    /// <summary>
    ///     Articles 分类下文章集合
    /// </summary>
    public List<Article> Articles { get; set; }
}
```
,为了表示某个文章属于某个文章分类,我还修改了Article数据模型类
```
/// <summary>
///     博客文章
/// </summary>
public class Article
{
    /// <summary>
    ///     Code 文章代码
    /// </summary>
    public string Code { get; set; }

    /// <summary>
    ///     Title 文章标题
    /// </summary>
    public string Title { get; set; }

    /// <summary>
    ///     CategoryId 文章所属的分类ID
    /// </summary>
    public int CategoryId { get; set; }

    /// <summary>
    ///     Category 文章所属的分类
    /// </summary>
    public Category Category { get; set; }
}
```
和Article表和数据模型类,新增了CategoryId来表示文章所属的分类ID和Category对象,现在我要怎么使用这两个类来操作数据库?

### 修改配置
首先,我们要修改一下原有的配置代码,原有的代码仅有Article的配置,显然我们需要增加Category的配置.

此外,我们还需要配置Article和Category之间的关系,关系配置是Obase引入的全新概念,引入了关系之后Obase可以更准确的追踪对象之间的关系变更,以实现更多的和关系相关的功能.

```
 /// <summary>使用指定的建模器创建对象数据模型。</summary>
 /// <param name="modelBuilder">对象数据模型建造器</param>
 protected override void CreateModel(ModelBuilder modelBuilder)
 {
     //对Article数据模型类进行配置
     var articleEntity = modelBuilder.Entity<Article>();
     //配置主键映射 和 主键是否自增
     articleEntity.HasKeyAttribute(p => p.Code).HasKeyIsSelfIncreased(false);
     //配置映射表
     articleEntity.ToTable("Article");

     //对Category数据模型类进行配置
     var categoryEntity = modelBuilder.Entity<Category>();
     //配置主键映射 和 主键是否自增
     categoryEntity.HasKeyAttribute(p => p.Id).HasKeyIsSelfIncreased(true);
     //配置映射表
     categoryEntity.ToTable("Category");

     //配置Article和Category之间的关系
     var categoryAssArticle = modelBuilder.Association();
     //Article和Category之间的关系中 一端是Article 在关联表中 Article的主键Code就是Code字段
     categoryAssArticle.AssociationEnd<Article>().HasMapping("Code", "Code");
     //Article和Category之间的关系中 一端是Category 在关联表中 Article的主键Id就是CategoryId字段
     categoryAssArticle.AssociationEnd<Category>().HasMapping("Id", "CategoryId");
     //Article和Category之间的关系存储于Article表
     categoryAssArticle.ToTable("Article");
 }
```
在新增了这些配置之后,我们就可以开始了.

### 一并保存
我们这次要新建一个分类,叫做默认分类并且在此分类下新增我们的第一篇文章,那么就可以写作如下代码:
```
//新增分类和文章
var category = new Category
{
    Name = "默认分类"
};
//构造文章时将分类赋值
var article = new Article
{
    Code = "A0001",
    Title = "第一篇文章",
    Category = category
};
//附加至上下文
context.Attach(category);
context.Attach(article);
//保存至数据库
context.SaveChanges();
```
当然,我们在之后添加文章时可能使用的是已有的分类,那么就可以写作如下的代码:
```
//先查询出之前的默认分类
var category = context.CreateSet<Category>().First(p => p.Name == "默认分类");
//构造文章时将分类赋值
var article = new Article
{
 Code = "A0002",
 Title = "第二篇文章",
 Category = category
};
//附加至上下文
context.Attach(category);
context.Attach(article);
//保存至数据库
context.SaveChanges();
```
这里的引用赋值实质上是建立了Category和Article之间的关系.

Obase会根据配置的实体型和关联型来侦测对象和对象间的关系,如果想要更详细的了解Obase的配置,请阅读[深入理解](./深入理解.md).
### 关联查询
以下介绍几种关联查询的方法.

由于我们在文章上定义了分类的ID,所以我们可以很轻易的写出根据分类ID查询文章的查询:
```
//查询分类ID为1的所有文章
var article = context.CreateSet<Article>().Where(p => p.CategoryId == 1).ToList();
```
我们在Article数据模型类里有引用Category,那么当然也可以在查询文章时同时查询文章的分类信息:
```
//查询Code为A0001的Article 并且 同时加载关联的Category
var article = context.CreateSet<Article>().Include(p => p.Category).FirstOrDefault(p => p.Code == "A0001");
```
这里使用了一个Obase的Linq扩展方法Include,此方法会在查询时同时加载Category对象.

当然我们也可以在查询Category时同时查询Article,
```
//查询分类ID为1的分类 并且 同时加载关联的Article
var articles = context.CreateSet<Category>().Include(p => p.Articles).Where(p => p.Id == 1).ToList();
```
Include的参数可以进行延展,比如再定义一个User对象并且在Article上定义Creator的关联引用,想要在查询分类时同时加载关联的Article和User,
就可以写作Include(p=>p.Articles.Select(q => q.Creator);

Obase还可以对关联对象是用投影,分组等操作,比如查询某个文章所属的分类可以使用这样的查询:
```
//查询Code为A0002的Article关联的Category
var category = context.CreateSet<Article>().Where(p => p.Code == "A0002").Select(p => p.Category).First();
```
自然可以从Category投影至Article,比如查询某个分类下所有的文章就可以使用平展投影:
```
//查询分类ID为1的分类下所有文章
var articles = context.CreateSet<Category>().Where(p => p.Id == 1).SelectMany(p => p.Articles).ToList();
```
更多的查询操作可以参考[Obase支持的关系运算](../Obase基础知识/Obase支持的关系运算.md).
### 解除关联
我们在之前一并保存里建立的关系自然是可以解除的:
```
//查询出Article
var article = context.CreateSet<Article>().Include(p => p.Category).FirstOrDefault(p => p.Code == "A0001");
//将Category置空
article.Category = null;
//保存至数据库
context.SaveChanges();
```
保存后可以发现Article的CategoryId被置空了但Category表内的数据并没有删除,因为此操作只解除了关联没有删除对象.