## 全面考虑的思路

以下所有内容中的,检查是否符合推断中的推断都指的是[Obase的配置有哪些默认值(dotNet版)](./Obase的配置有哪些默认值(dotNet版).md)里的推断.

1. **注册程序集**.在重写的配置方法中,将领域模型的Assembly调用modelBuilder.RegisterType方法注册.这样做可以将整个领域模型中符合推断的类型都注册为Obase的对象模型类型,之后碰到配置的类型如果符合推断就无需再次进行配置了.

2. **添加忽略类型**.领域模型内可能存在一些不需要Obase管理的类,如某些接口的默认实现类,不需要独立存储的类等,将这些类型调用modelBuilder.Ignore方法忽略掉.

3. **检查实体型配置**.挑选一个要配置为实体型类检查.依次检查以下几项:
    1. 是否符合推断?不符合,则要调用Entity方法将其注册为实体型配置.符合,暂时不调用Entity方法创建实体配置项如果以下几个都符合推断,则不需要创建,否则仍需要创建实体配置.
    2. 是否符合主键推断?是否符合主键自增的推断?不符合,则需要在实体型配置调用HasKeyAttribute和HasKeyIsSelfIncreased.符合则不需要调用.
    3. 是否符合构造函数推断?不符合则需要实体型配置调用HasConstructor方法配置.符合则不需要调用.
    4. 是否符合映射表推断?不符合则需要实体型配置调用ToTable方法配置,符合则不需要调用.
    5. (可选)是否需要配置并发冲突相关配置?是否需要配置对象变更通知相关配置?如果需要,则在实体型配置上调用相应的方法.

4. **检查实体型的属性配置**.继续对第三步的类属性进行检查,以确定属性和关联引用.
    1. 是否是一个属性?是否符合属性的推断?不符合,则需要实体型配置调用Attribute方法配置,符合则不需要.
    2. (可选)是否需要配置属性的并发冲突策略?是否需要配置精度,最大长度,是否可空?如果需要,则在属性配置上调用相应的方法.
    3. 是否是一个关联引用?如果是隐式关联的关联引用(即关联引用的元素类型是另外一个实体型),转入**步骤5**.如果是显式关联的关联引用(即关联引用的元素类型是显式关联型),转入**步骤6.**

5. **检查隐式关联型的配置**.按照以下步骤检查此隐式关联:
    1. 是否是一个标准的两方或多方隐式关联(即引用是否是关系的另外一方或者用元组Tuple组成的多方)?如果不是,则需要调用modelBuilder.Association方法启动一个新的隐式关联建造器进行配置.否则,继续检查以下几项,如果都符合推断,则不需要配置.
    2. 检查此关联型的映射表是否符合推断?如果不符合,调用隐式关联建造器ToTable方法配置;否则不需要配置.
    3. 检查关联的每一方,是否都符合推断?如果不是,则需要调用隐式关联建造器的AssociationEnd方法声明关联端,并配置相应的映射,取值器,设值器等.否则不需要配置.
    4. 检查检查关联的每一方的关联端,端上针对此关联型的关联引用是否符合推断?不符合则需要配置相应的取值器,设值器,是否延迟加载等.否则不需要配置.
    5. (可选)检查关联的每一方的关联端,是否都是用默认的延迟加载,是否聚合,是否默认附加至上下文?如果不符合,则调用相应的方法配置.否则不需要配置.

6. **检查显式关联型的配置**.按照以下步骤检查此显式关联:
    1. 此显式关联是否符合推断?如果不是,则需要调用modelBuilder.Association<>方法配置显式关联型,否则,继续检查以下几项,如果都符合推断,则不需要配置.
    2. 检查此关联型的映射表是否符合推断?如果不符合,调用显式关联型配置的ToTable方法配置;否则不需要配置.
    3. 检查关联的每一方,是否都符合推断?如果不是,则需要调用隐式关联建造器的AssociationEnd方法声明关联端,并配置相应的映射,取值器,设值器等.否则不需要配置.
    4. 检查检查关联的每一方的关联端,端上针对此关联型的关联引用是否符合推断?不符合则需要配置相应的取值器,设值器,是否延迟加载等.否则不需要配置.

7. **重复以上的步骤3至步骤6**,直到所有的类型都被配置完成.

## 简明思路

Obase的配置实质上只关心这些内容:
- 哪些类型是实体型,哪些类型是关联型,这些类型如何映射.
- 这些实体型之间的关系是如何映射的.
- 这些实体型和关联型上的属性是如何映射的.

所以只要配置这些基础的配置就可以构建对象数据模型了,那么就有如下的简明配置思路.

1. 将要配置的对象系统中所有的由Obase管理存储的类型分类为实体型(表示一个实体,有主键的类型)和显式关联型(表示实体之间的关系,且有属于关系的属性)这两个类别.
2. 将所有的实体型都调用modelBuilder的Entity<>()注册为实体型,并且配置主键和映射表,代码类似于以下三行```var cfg = modelBuilder.Entity<XXX>(); cfg.HasKeyAttribute(p => p.XXX); cfg.ToTable("XXX");```.
3. 将所有的显式关联型都调用modelBuilder的Association<>()注册为显式关联型,并配置关联型的关联端及端映射和关联的映射表,代码类似于以下四行```var cdg = modelBulder.Association<XXX>();cfg.AssociationEnd(p=>p.XXX).HasMapping("XXX","XXX");cfg.AssociationEnd(p=>p.YYY).HasMapping("YYY","YYY");cfg.ToTable("XXX"); ```一个关联至少有两个实体型参与,所以此处至少需要两个关联端.
4. 检查所有的实体型,这些实体型除了基元类型的属性以外,是否还引用了其他的实体型,如果有这些实体型的引用代表存在隐含的关联,需要将这些隐含的关联注册为隐式关联型,并配置关联型的关联端及端映射和关联的映射表,代码类似于以下四行```var cfg = modelBuilder.Association();cfg.AssociationEnd<XXX>().HasMapping("XXX","XXX"); cfg.AssociationEnd<YYY>().HasMapping("YYY","YYY");cfg.ToTable("XXX");```一个关联至少有两个实体型参与,所以此处至少需要两个关联端.
5. 反复使用以上的代码,将所有的实体型和关联型都注册,需要注意的是如果A和B有隐式关联,只需要注册一次即可除非A和B存在多个不同的关系.
6. 检查所有的实体型和关联型上的普通属性和构造器,这些属性和构造器是否需要特殊的处理,如果需要为其配置相应的取值器设值器映射等配置.检查所有的实体型上的其他实体型或关联型的引用属性,这些属性是否需要特殊的处理,如果需要为其配置相应的取值器设值器等配置.
7. 最后,如果有需要特殊配置的,如继承配置,对象更改通知,两个类之间有多个关系之类的,参照Obase的进阶使用中相关的内容进行配置即可.